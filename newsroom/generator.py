"""
Content generator for newsroom.

This module orchestrates the generation of markdown files from news sources.
"""

from datetime import datetime
from typing import List, Dict, Optional, Type
import logging
import os

from .sources.base import NewsSource
from .sources.google_news import GoogleNewsScraper
from .summarizer import LLMSummarizer
from . import utils

logger = logging.getLogger(__name__)

class NewsDigestGenerator:
    """Generates daily news digests in markdown format."""
    
    def __init__(
        self,
        source_class: Type[NewsSource] = GoogleNewsScraper,
        max_stories: int = 10,
        use_llm: bool = True,
        llm_model: str = "gpt-4o",
        llm_temperature: float = 0.5,
        output_dir: str = "content"
    ):
        """Initialize the generator.
        
        Args:
            source_class: News source class to use (default: GoogleNewsScraper)
            max_stories: Maximum number of stories to include (default: 10)
            use_llm: Whether to use LLM summarization (default: True)
            llm_model: OpenAI model to use (default: gpt-4o)
            llm_temperature: Model temperature (default: 0.5)
            output_dir: Directory for output files (default: "content")
        """
        self.output_dir = output_dir
        self.news_source = source_class(max_stories=max_stories)
        self.use_llm = use_llm
        
        if use_llm:
            try:
                self.summarizer = LLMSummarizer(
                    model=llm_model,
                    temperature=llm_temperature
                )
            except ValueError as e:
                logger.warning(f"Failed to initialize LLM summarizer: {str(e)}")
                self.use_llm = False
    
    def _get_file_path(self, date: datetime) -> str:
        """Get the file path for a given date's digest.
        
        Args:
            date: datetime object
            
        Returns:
            Path to the markdown file
        """
        return os.path.join(
            self.output_dir,
            f"{date.strftime('%Y-%m-%d')}.md"
        )
    
    def generate_markdown(self, stories: List[Dict[str, str]], date: Optional[datetime] = None) -> str:
        """Generate markdown content from stories.
        
        Args:
            stories: List of story dictionaries
            date: Optional datetime object (defaults to today)
            
        Returns:
            Markdown formatted string
        """
        date = date or datetime.now()
        formatted_date = utils.format_date_for_title(date)
        
        # Generate article summaries if LLM is enabled
        article_summaries = []
        if self.use_llm:
            for story in stories:
                summary = None
                if story.get('summary'):
                    try:
                        summary = self.summarizer.summarize_article(story['summary'])
                    except Exception as e:
                        logger.warning(f"Failed to summarize article: {str(e)}")
                article_summaries.append(summary or "No summary available.")
        
        # Generate daily overview if LLM is enabled
        daily_overview = None
        if self.use_llm and article_summaries:
            try:
                daily_overview = self.summarizer.summarize_day(article_summaries)
            except Exception as e:
                logger.warning(f"Failed to generate daily overview: {str(e)}")
        
        # Generate frontmatter and header
        content = [
            "---",
            f'title: "Top Headlines for {formatted_date}"',
            f'pubDate: "{date.strftime("%Y-%m-%d")}"',
            'description: "Daily news summary generated by AI."',
            "---",
            "",
            f"# üóûÔ∏è Vibe News Digest ‚Äì {date.strftime('%Y-%m-%d')}",
            ""
        ]
        
        # Add summary section
        content.extend([
            "## üß† Summary",
            ""
        ])
        
        if self.use_llm and daily_overview:
            content.append(daily_overview)
        else:
            content.append("_(Summarization disabled in this run)_")
        
        content.extend([
            "",
            "---",
            "",
            "## üì∞ Top Stories",
            ""
        ])
        
        # Add each story
        for i, (story, summary) in enumerate(zip(stories, article_summaries if self.use_llm else [None] * len(stories))):
            content.extend([
                f"### {story['title']}",
                f"*{story['source']}* ‚Äì [Read full article]({story['url']})",
                ""
            ])
            
            if self.use_llm and summary and summary != "No summary available.":
                content.append(summary)
                content.append("")
            
            if i < len(stories) - 1:  # Don't add divider after last story
                content.append("---")
                content.append("")
        
        return "\n".join(content)
    
    def generate_digest(self, date: Optional[datetime] = None, force: bool = False) -> bool:
        """Generate a news digest for the specified date.
        
        Args:
            date: Optional datetime object (defaults to today)
            force: Whether to overwrite existing digest (default: False)
            
        Returns:
            True if digest was generated, False otherwise
        """
        date = date or datetime.now()
        file_path = self._get_file_path(date)
        
        # Check if digest already exists
        if not force and os.path.exists(file_path):
            logger.info(f"Digest already exists for {date.strftime('%Y-%m-%d')}")
            return False
        
        # Ensure output directory exists
        os.makedirs(self.output_dir, exist_ok=True)
        
        # Fetch stories
        try:
            stories = self.news_source.get_stories()
            if not stories:
                logger.error("No stories found")
                return False
        except Exception as e:
            logger.error(f"Failed to fetch stories: {str(e)}")
            return False
        
        # Generate and write markdown
        try:
            markdown = self.generate_markdown(stories, date)
            with open(file_path, 'w') as f:
                f.write(markdown)
        except Exception as e:
            logger.error(f"Failed to generate or write digest: {str(e)}")
            return False
        
        logger.info(f"Generated digest at {file_path}")
        return True 